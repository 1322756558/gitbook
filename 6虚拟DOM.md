### 虚拟DOM

虚拟DOM本质上是为了解决在更新DOM结点树的时候的速度问题, 基础的DOM操作的时候, 当我们修改或更新一个结点时需要重新建立DOM树, 打个比方, 一个ul标签下的一个li标签改动, 一般来说要用新的ul去代替旧的ul, 这浪费了很多不必要的性能

为了解决这个问题, vue使用了虚拟DOM, 他主要干了两个事情:

- 提供与真实DOM结点对应的虚拟结点vnode
- 将虚拟结点vnode和旧虚拟结点oldvnode进行对比, 然后更新视图

与纯js代码相比对DOM结点的操作是一个相当费时费力的操作, 所以可以理解成在DOM操作之前添加了一层js来辅助对比与之前的DOM结点有什么不同, 以减少对DOM的操作

知道了DOM的原理我们就可以具体来看看他是怎么对比两颗DOM树的不同结点的,  我们知道对比两棵树的算法时间复杂度是O(n3), 这是一个很慢的算法, 而对DOM树来说又很少有跨层级的操作, 所以vue采用了仅对比同级vnode的方法,递归的进行同级间vnode的对比, 将O(n3)变成了O(n)



![img](https://image.fundebug.com/2019-06-26-03.png)

在之后我们将差异位置应用到真正的DOM树上, 视图就更新了

之后我们深入的理解一下这个diff算法, 就像上面说的这个算法是同级对比, 比如我们如果将c结点移动到b结点下, 理想的方式是将c移动到b下, 实现结点复用, 但由于是同级比较, 所以vue的做法是删除c结点然后在b下新建一个c所幸这种操作并不常见

![1568601178550](D:\mydir\vue笔记\DOM跨级移动.png)



在diff算法中key的作用:

在没有key属性的情况下

![1568601604433](D:\mydir\vue笔记\无key移动.png)

key属性可以唯一标识一个结点, 比如我们面临上面的情况, 理想的情况是将b1和b2的位置互换, 但是如果我们不没有添加key属性, 那么vue无法识别b1和b2, 他会将b1变成b2, 然后重新添加ef, 如果添加了key, 那么vue就可以识别出其实是他们两个是换了位置, 按照理想的方式来互换结点位置, 实现结点复用

同理当我们进行添加操作的时候, 如果都没有key属性的存在

![1568602011433](D:\mydir\vue笔记\无key插入.png)

vue会b2更新为b4, b3更新为b2, 添加一个b3

**所以, 如果你的代码结点中如果可以预期到未来会对结点进行插入或互换位置, 那么建议你添加一个key属性, 虽然影响并不大, 但还是从细微处节省每一点点的时间**

然后其实如果对DOM操作很少的情况下很少能看到vue这样做法的优越性, 只有面临大面积DOM操作的时候才能看到这个方法的优越性

最后:vue是双向比对算法，最终的一个更新顺序是比较难预测的，不像react单向比对，不过在虚拟dom里面，更新顺序并不重要，最终关注的只是结果

